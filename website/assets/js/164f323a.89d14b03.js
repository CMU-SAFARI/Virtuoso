"use strict";(self.webpackChunkvirtuoso=self.webpackChunkvirtuoso||[]).push([[839],{7768:(e,n,s)=>{s.r(n),s.d(n,{assets:()=>l,contentTitle:()=>a,default:()=>h,frontMatter:()=>c,metadata:()=>t,toc:()=>o});const t=JSON.parse('{"id":"TLB Subsystem/tlb","title":"Translation Lookaside Buffer (TLB) Overview","description":"This document provides an overview of a Translation Lookaside Buffer (TLB) implementation within the ParametricDramDirectoryMSI namespace. The TLB code, as well as its interaction with caches, prefetchers, and related memory subsystems, is described here. The goal of this TLB is to cache virtual-to-physical page translations, accelerating address translation requests and reducing memory access latencies.","source":"@site/docs/TLB Subsystem/tlb.md","sourceDirName":"TLB Subsystem","slug":"/TLB Subsystem/tlb","permalink":"/docs/TLB Subsystem/tlb","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/TLB Subsystem/tlb.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Reservation-based Transparent Huge Pages","permalink":"/docs/Physical Memory Allocators/reserve_thp"},"next":{"title":"TLB Subsystem Overview","permalink":"/docs/TLB Subsystem/tlb_hierarchy"}}');var i=s(4848),r=s(8453);const c={},a="Translation Lookaside Buffer (TLB) Overview",l={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"Data Structures and Classes",id:"data-structures-and-classes",level:2},{value:"<code>TLB</code>",id:"tlb",level:3},{value:"<code>CacheBlockInfo</code>",id:"cacheblockinfo",level:3},{value:"<code>SubsecondTime</code>",id:"subsecondtime",level:3},{value:"<code>PageTable</code>",id:"pagetable",level:3},{value:"Other Includes",id:"other-includes",level:3},{value:"Key Functions",id:"key-functions",level:2},{value:"Constructor",id:"constructor",level:3},{value:"<code>allocate()</code>",id:"allocate",level:3},{value:"Statistics Tracking",id:"statistics-tracking",level:3},{value:"Prefetching Support",id:"prefetching-support",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(n.header,{children:(0,i.jsx)(n.h1,{id:"translation-lookaside-buffer-tlb-overview",children:"Translation Lookaside Buffer (TLB) Overview"})}),"\n",(0,i.jsxs)(n.p,{children:["This document provides an overview of a ",(0,i.jsx)(n.strong,{children:"Translation Lookaside Buffer (TLB)"})," implementation within the ParametricDramDirectoryMSI namespace. The TLB code, as well as its interaction with caches, prefetchers, and related memory subsystems, is described here. The goal of this TLB is to cache virtual-to-physical page translations, accelerating address translation requests and reducing memory access latencies."]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,i.jsxs)(n.ol,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#data-structures-and-classes",children:"Data Structures and Classes"})}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.a,{href:"#key-functions",children:"Key Functions"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#constructor",children:"Constructor"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#lookup",children:"lookup()"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#allocate",children:"allocate()"})}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#statistics-tracking",children:"Statistics Tracking"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#prefetching-support",children:"Prefetching Support"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#code-listing",children:"Code Listing"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#usage-example",children:"Usage Example"})}),"\n",(0,i.jsx)(n.li,{children:(0,i.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,i.jsxs)(n.p,{children:["A ",(0,i.jsx)(n.strong,{children:"Translation Lookaside Buffer (TLB)"})," is a critical hardware (or hardware-assisted) structure used for address translation in modern computer architectures. When an application references a virtual address, the TLB quickly looks up the corresponding physical address (if one exists in the TLB), saving time compared to performing a full page table walk in memory."]}),"\n",(0,i.jsx)(n.p,{children:"In this code, you will see how we:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Instantiate a TLB with different page sizes."}),"\n",(0,i.jsx)(n.li,{children:"Use the TLB to check for hits and misses."}),"\n",(0,i.jsx)(n.li,{children:"Handle TLB fills and evictions."}),"\n",(0,i.jsx)(n.li,{children:"Integrate with other memory system components like prefetchers and caches."}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"data-structures-and-classes",children:"Data Structures and Classes"}),"\n",(0,i.jsx)(n.h3,{id:"tlb",children:(0,i.jsx)(n.code,{children:"TLB"})}),"\n",(0,i.jsx)(n.p,{children:"The core class representing our translation lookaside buffer. It includes:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Cache"}),": An internal cache-like structure that stores address-to-page translations."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Statistics"}),": Counters for hits, misses, evictions, etc."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"Prefetchers"}),": References to optional prefetcher structures that can be enabled if desired."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"cacheblockinfo",children:(0,i.jsx)(n.code,{children:"CacheBlockInfo"})}),"\n",(0,i.jsx)(n.p,{children:"A supporting class that typically holds metadata about an individual cache/TLB line (e.g., its tag, page size, replacement state)."}),"\n",(0,i.jsx)(n.h3,{id:"subsecondtime",children:(0,i.jsx)(n.code,{children:"SubsecondTime"})}),"\n",(0,i.jsx)(n.p,{children:"A utility class (not fully shown) that measures time in subsecond resolution, used to keep track of timing events like cache hits/misses and TLB lookups."}),"\n",(0,i.jsx)(n.h3,{id:"pagetable",children:(0,i.jsx)(n.code,{children:"PageTable"})}),"\n",(0,i.jsx)(n.p,{children:"A hypothetical page table class. The TLB can consult the page table for translations when needed."}),"\n",(0,i.jsx)(n.h3,{id:"other-includes",children:"Other Includes"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"stats.h"})}),": Provides statistics tracking."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"config.hpp"})}),": Configurations for the system (e.g., cache/TLB parameters)."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"cache_cntlr.h"})}),": Manages cache-level operations."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"memory_manager.h"})}),": Orchestrates higher-level memory processes."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:(0,i.jsx)(n.code,{children:"core_manager.h"})}),": Manages CPU cores and associated resources."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsxs)(n.strong,{children:[(0,i.jsx)(n.code,{children:"cache_set.h"}),", ",(0,i.jsx)(n.code,{children:"cache_base.h"}),", ",(0,i.jsx)(n.code,{children:"utils.h"}),", ",(0,i.jsx)(n.code,{children:"log.h"}),", ",(0,i.jsx)(n.code,{children:"rng.h"}),", ",(0,i.jsx)(n.code,{children:"address_home_lookup.h"}),", ",(0,i.jsx)(n.code,{children:"fault_injection.h"})]}),": Various helper modules for logging, random number generation, fault injection, address calculations, etc."]}),"\n"]}),"\n",(0,i.jsx)(n.hr,{}),"\n",(0,i.jsx)(n.h2,{id:"key-functions",children:"Key Functions"}),"\n",(0,i.jsx)(n.h3,{id:"constructor",children:"Constructor"}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'TLB::TLB(String name,\n         String cfgname,\n         core_id_t core_id,\n         ComponentLatency access_latency,\n         UInt32 num_entries,\n         UInt32 associativity,\n         int *page_size_list,\n         int page_sizes,\n         String tlb_type,\n         bool allocate_on_miss,\n         bool prefetch,\n         TLBPrefetcherBase **tpb,\n         int _number_of_prefetchers,\n         int _max_prefetch_count)\n   : m_size(num_entries),\n     m_core_id(core_id),\n     m_name(name),\n     m_associativity(associativity),\n     m_cache(name + "_cache", cfgname, core_id, num_entries / associativity,\n             associativity, (1L << 3), "lru", CacheBase::PR_L1_CACHE,\n             CacheBase::HASH_MASK, NULL, NULL, true,\n             page_size_list, page_sizes),\n     m_type(tlb_type),\n     m_page_size_list(NULL),\n     m_page_sizes(page_sizes),\n     m_allocate_miss(allocate_on_miss),\n     m_prefetch(prefetch),\n     prefetchers(tpb),\n     number_of_prefetchers(_number_of_prefetchers),\n     max_prefetch_count(_max_prefetch_count),\n     m_access_latency(access_latency)\n{\n    // Ensure valid TLB configuration\n    LOG_ASSERT_ERROR((num_entries / associativity) * associativity == num_entries,\n                     "Invalid TLB configuration: num_entries(%d) must be a multiple of the associativity(%d)",\n                     num_entries, associativity);\n\n    // Allocate array of page sizes\n    m_page_size_list = std::unique_ptr<int[]>(new int[m_page_sizes]);\n    for (int i = 0; i < m_page_sizes; i++) {\n        m_page_size_list[i] = page_size_list[i];\n    }\n\n    // Zero out TLB statistics and register them\n    bzero(&tlb_stats, sizeof(tlb_stats));\n    registerStatsMetric(name, core_id, "access", &tlb_stats.m_access);\n    registerStatsMetric(name, core_id, "eviction", &tlb_stats.m_eviction);\n    registerStatsMetric(name, core_id, "miss", &tlb_stats.m_miss);\n}\n### Parameters\n\n- **name, cfgname**: Identifiers for the TLB and its configuration.\n- **core_id**: ID of the core this TLB is attached to.\n- **access_latency**: Latency for accesses to this TLB.\n- **num_entries, associativity**: Overall capacity and associativity.\n- **page_size_list**: List of supported page sizes.\n- **tlb_type**: A string descriptor (e.g. "L1_TLB", "L2_TLB").\n- **allocate_on_miss**: Flag that determines if we insert a new translation on miss.\n- **prefetch**: Enables or disables any attached TLB prefetchers.\n- **prefetchers**: Array of TLB prefetcher objects.\n- **_number_of_prefetchers, _max_prefetch_count**: Additional prefetcher configuration.\n\n### Notes\n\n- Instantiates the TLB\u2019s internal cache structure.\n- Registers TLB stats like misses, hits, and evictions.\n\n### `lookup()`\n\n```cpp\nCacheBlockInfo* TLB::lookup(IntPtr address,\n                            SubsecondTime now,\n                            bool model_count,\n                            Core::lock_signal_t lock_signal,\n                            IntPtr eip,\n                            bool modeled,\n                            bool count,\n                            PageTable* pt)\n{\n    if (model_count)\n        tlb_stats.m_access++;\n\n#ifdef DEBUG_TLB\n    std::cout << "TLB " << m_name << " Lookup: " << address << std::endl;\n#endif\n\n    // Access the internal cache structure for this address\n    CacheBlockInfo* hit = m_cache.accessSingleLineTLB(address, Cache::LOAD, NULL, 0, now, true);\n\n#ifdef DEBUG_TLB\n    if (hit)\n        std::cout << " Hit at level: " << m_name << std::endl;\n    else\n        std::cout << " Miss at level: " << m_name << std::endl;\n#endif\n\n    // If we got a TLB hit\n    if (hit)\n    {\n        tlb_stats.m_hit++;\n        return hit;\n    }\n\n    // If not found, count as a miss if needed\n    if (model_count)\n        tlb_stats.m_miss++;\n\n    return NULL;\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Checks if a given virtual address is present in the TLB."}),"\n",(0,i.jsxs)(n.li,{children:["If ",(0,i.jsx)(n.code,{children:"model_count"})," is true, updates the total access count and later the miss count."]}),"\n",(0,i.jsxs)(n.li,{children:["Returns a pointer to the ",(0,i.jsx)(n.code,{children:"CacheBlockInfo"})," if found, or ",(0,i.jsx)(n.code,{children:"NULL"})," otherwise."]}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Debugging"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"#ifdef DEBUG_TLB"})," blocks can be enabled to print detailed debug information to standard output."]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"allocate",children:(0,i.jsx)(n.code,{children:"allocate()"})}),"\n",(0,i.jsx)(n.pre,{children:(0,i.jsx)(n.code,{className:"language-cpp",children:'std::tuple<bool, IntPtr, int> TLB::allocate(IntPtr address,\n                                           SubsecondTime now,\n                                           bool count,\n                                           Core::lock_signal_t lock_signal,\n                                           int page_size,\n                                           IntPtr ppn,\n                                           bool self_alloc)\n{\n    if (getPrefetch() && !self_alloc)\n    {\n        // If prefetching is enabled, skip direct allocation unless it\'s a self_alloc\n        return std::make_tuple(false, 0, 0);\n    }\n    IntPtr evict_addr;\n    CacheBlockInfo evict_block_info;\n\n    IntPtr tag;\n    UInt32 set_index;\n\n    // Extract set index and tag based on page size\n    m_cache.splitAddressTLB(address, tag, set_index, page_size);\n\n#ifdef DEBUG_TLB\n    std::cout << " Allocate " << address << " at level: " << m_name\n              << " with page_size " << page_size\n              << " and tag " << tag << std::endl;\n#endif\n\n    bool eviction = false;\n\n    // Insert a new translation line into the TLB\n    m_cache.insertSingleLineTLB(address, NULL, &eviction, &evict_addr,\n                                &evict_block_info, NULL, now, NULL,\n                                CacheBlockInfo::block_type_t::NON_PAGE_TABLE,\n                                page_size, ppn);\n\n    // Count evictions if needed\n    if (eviction && count)\n        tlb_stats.m_eviction++;\n\n#ifdef DEBUG_TLB\n    if (eviction)\n        std::cout << " Evicted " << evict_addr << " from level: " << m_name\n                  << " with page_size " << page_size << std::endl;\n#endif\n\n    // Return tuple: (was there an eviction?, evicted address, evicted page size)\n    return std::make_tuple(eviction, evict_addr, evict_block_info.getPageSize());\n}\n'})}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Purpose"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Inserts a new translation line into the TLB if it is not found (on a miss)."}),"\n",(0,i.jsx)(n.li,{children:"Evicts an old entry if no free lines exist in the set."}),"\n",(0,i.jsx)(n.li,{children:"Returns info about whether something was evicted, which address was evicted, and what the evicted page size was."}),"\n"]}),"\n",(0,i.jsxs)(n.p,{children:[(0,i.jsx)(n.strong,{children:"Key Logic"}),":"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"m_cache.splitAddressTLB(address, tag, set_index, page_size);"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Splits the incoming address into a tag and set index, factoring in the page_size."}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.code,{children:"m_cache.insertSingleLineTLB(...)"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"Actually performs the insertion, populating it with a physical page number (ppn)."}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(n.h3,{id:"statistics-tracking",children:"Statistics Tracking"}),"\n",(0,i.jsx)(n.p,{children:"This TLB tracks statistics such as:"}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"m_access"}),": Number of accesses made to the TLB."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"m_hit"}),": Number of hits in the TLB."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"m_miss"}),": Number of misses in the TLB."]}),"\n",(0,i.jsxs)(n.li,{children:[(0,i.jsx)(n.strong,{children:"m_eviction"}),": Number of evictions that occurred during TLB insertions."]}),"\n"]}),"\n",(0,i.jsx)(n.p,{children:"At the end of execution or during simulation, these metrics can be retrieved and logged for performance analysis."}),"\n",(0,i.jsx)(n.h3,{id:"prefetching-support",children:"Prefetching Support"}),"\n",(0,i.jsxs)(n.p,{children:["If enabled (",(0,i.jsx)(n.code,{children:"m_prefetch == true"}),"), the TLB can work with one or more TLB prefetchers:"]}),"\n",(0,i.jsxs)(n.ul,{children:["\n",(0,i.jsx)(n.li,{children:"A prefetcher might predict which translations will be needed soon and preemptively load them into the TLB."}),"\n",(0,i.jsxs)(n.li,{children:["The ",(0,i.jsx)(n.code,{children:"allocate()"})," function checks whether it\u2019s a self-allocation vs. a prefetch request to decide whether to proceed with a new entry insertion."]}),"\n"]})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,i.jsx)(n,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,n,s)=>{s.d(n,{R:()=>c,x:()=>a});var t=s(6540);const i={},r=t.createContext(i);function c(e){const n=t.useContext(r);return t.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:c(e.components),t.createElement(r.Provider,{value:n},e.children)}}}]);