"use strict";(self.webpackChunkvirtuoso=self.webpackChunkvirtuoso||[]).push([[144],{7995:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>r,contentTitle:()=>l,default:()=>f,frontMatter:()=>o,metadata:()=>s,toc:()=>d});const s=JSON.parse('{"id":"MMU Designs/mmu_pomtlb","title":"Part-of-Memory TLB (POM-TLB) MMU Design","description":"In this section, we will discuss the implementation of the Part-of-Memory TLB (POM-TLB) MMU design. The POM-TLB design is a software-managed TLB that uses a software-managed L3 TLB to reduce the overhead of address translation. The POM-TLB design is based on the work by Papadopoulou et al..","source":"@site/docs/MMU Designs/mmu_pomtlb.md","sourceDirName":"MMU Designs","slug":"/MMU Designs/mmu_pomtlb","permalink":"/Virtuoso/website/docs/MMU Designs/mmu_pomtlb","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/MMU Designs/mmu_pomtlb.md","tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Baseline MMU","permalink":"/Virtuoso/website/docs/MMU Designs/baseline_mmu"},"next":{"title":"Range Mappings MMU Design","permalink":"/Virtuoso/website/docs/MMU Designs/mmu_rmm"}}');var i=n(4848),a=n(8453);const o={sidebar_position:2},l="Part-of-Memory TLB (POM-TLB) MMU Design",r={},d=[];function c(e){const t={a:"a",code:"code",h1:"h1",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"part-of-memory-tlb-pom-tlb-mmu-design",children:"Part-of-Memory TLB (POM-TLB) MMU Design"})}),"\n",(0,i.jsxs)(t.p,{children:["In this section, we will discuss the implementation of the Part-of-Memory TLB (POM-TLB) MMU design. The POM-TLB design is a software-managed TLB that uses a software-managed L3 TLB to reduce the overhead of address translation. The POM-TLB design is based on the work by ",(0,i.jsx)(t.a,{href:"https://ieeexplore.ieee.org/document/8192494",children:"Papadopoulou et al."}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["We will describe only the differences between the POM-TLB and the baseline MMU design. For a detailed description of the baseline MMU design, please refer to the ",(0,i.jsx)(t.a,{href:"./mmu_baseline.md",children:"Baseline MMU Design"})," section."]}),"\n",(0,i.jsx)(t.p,{children:"This code implements the handling of TLB (Translation Lookaside Buffer) misses in a memory management unit (MMU). It differentiates between hardware TLB and software TLB, and performs a lookup in the software TLB when a hardware TLB miss occurs. Below are the key differences and functionalities explained:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Hardware TLB Miss Handling"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["When a TLB miss occurs (",(0,i.jsx)(t.code,{children:"!tlb_hit"}),"), the code initiates a search in the software TLB structures for the requested address."]}),"\n",(0,i.jsxs)(t.li,{children:["Debug logs are generated (if ",(0,i.jsx)(t.code,{children:"DEBUG_MMU"})," is enabled) to trace the TLB miss and subsequent software TLB lookup process."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Software TLB Lookup"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The software TLB is organized by page sizes, and the code iterates through all possible page sizes (",(0,i.jsx)(t.code,{children:"number_of_page_sizes"}),") to perform the lookup."]}),"\n",(0,i.jsxs)(t.li,{children:["For each page size:","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The corresponding software TLB (",(0,i.jsx)(t.code,{children:"m_pom_tlb[page_size]"}),") is queried using the ",(0,i.jsx)(t.code,{children:"lookup"})," method."]}),"\n",(0,i.jsx)(t.li,{children:"Debug logs provide detailed information about the lookup process, including the page size, tag, set index, and base address used for the lookup."}),"\n",(0,i.jsx)(t.li,{children:"The memory access latency for the software TLB is simulated and recorded."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'#ifdef DEBUG_MMU\n\t\t\tlog_file << "[MMU] TLB Miss, checking software TLB" << std::endl;\n#endif\n            // We need to check multiple software TLBs (one for each page size)\n\t\t\tfor (int page_size = 0; page_size < number_of_page_sizes; page_size++)\n\t\t\t{\n#ifdef DEBUG_MMU\n\t\t\t\tlog_file << "[MMU] Searching software TLB for page size: "\n\t\t\t\t         << page_size_list[page_size] << std::endl;\n#endif\n\t\t\t\tTLB* pom = m_pom_tlb[page_size];\n\t\t\t\tsoftware_tlb_block_info = pom->lookup(address, time, count, lock, eip, modeled, count, NULL);\n\n#ifdef DEBUG_MMU\n\t\t\t\tlog_file << "[MMU] Software TLB Hit ? "\n\t\t\t\t         << (software_tlb_block_info != NULL)\n\t\t\t\t         << " at TLB: " << pom->getName() << std::endl;\n#endif\n\n\t\t\t\t// Simulate the memory access that the software TLB structure does\n\t\t\t\ttranslationPacket packet;\n\t\t\t\tpacket.eip          = eip;\n\t\t\t\tpacket.instruction  = false;\n\t\t\t\tpacket.lock_signal  = lock;\n\t\t\t\tpacket.modeled      = modeled;\n\t\t\t\tpacket.count        = count;\n\t\t\t\tpacket.type         = CacheBlockInfo::block_type_t::TLB_ENTRY;\n\n\t\t\t\tIntPtr tag;\n\t\t\t\tUInt32 set_index;\n\t\t\t\tpom->getCache().splitAddressTLB(address, tag, set_index, page_size_list[page_size]);\n\n#ifdef DEBUG_MMU\n\t\t\t\tlog_file << "[MMU] Software TLB Lookup: " << address\n\t\t\t\t         << " at page size: " << page_size_list[page_size]\n\t\t\t\t         << " with tag: " << tag\n\t\t\t\t         << " and set index: " << set_index\n\t\t\t\t         << " and base address: "\n\t\t\t\t         << software_tlb_base_register[page_size]*4096 << std::endl;\n#endif\n\t\t\t\tpacket.address = software_tlb_base_register[page_size]*4096\n\t\t\t\t                 + pom->getAssoc()* pom->getEntrySize() * set_index;\n\n#ifdef DEBUG_MMU\n\t\t\t\tlog_file << "[MMU] Software TLB Address: " << packet.address << std::endl;\n#endif\n\n\t\t\t\tsoftware_tlb_latency[page_size] = accessCache(packet, time_before_software_tlb);\n\n#ifdef DEBUG_MMU\n\t\t\t\tlog_file << "[MMU] Software TLB Latency: " \n\t\t\t\t         << software_tlb_latency[page_size]\n\t\t\t\t         << " at page size: " << page_size_list[page_size] \n\t\t\t\t         << std::endl;\n#endif\n\n}\n'})}),"\n",(0,i.jsxs)(t.ol,{start:"3",children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Software TLB Hit"}),":","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["If a software TLB hit occurs (",(0,i.jsx)(t.code,{children:"software_tlb_block_info != NULL"}),"):","\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsx)(t.li,{children:"The physical page number (PPN) and page size of the hit are retrieved."}),"\n",(0,i.jsxs)(t.li,{children:["The latency of the software TLB hit is recorded as ",(0,i.jsx)(t.code,{children:"final_software_tlb_latency"}),"."]}),"\n",(0,i.jsx)(t.li,{children:"Debug logs provide detailed information about the hit, including the PPN, VPN, tag, and latency."}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'if (software_tlb_block_info != NULL)\n{\n    // We have a software TLB hit\n    final_software_tlb_latency = software_tlb_latency[page_size];\n    software_tlb_hit = true;\n    ppn_result = software_tlb_block_info->getPPN();\n    page_size_result = software_tlb_block_info->getPageSize();\n#ifdef DEBUG_MMU\n    log_file << "[MMU] Software TLB Hit at page size: "\n                << page_size_result << std::endl;\n    log_file << "[MMU] Software TLB Hit PPN: " << ppn_result << std::endl;\n    log_file << "[MMU] Software TLB Hit VPN: "\n                << (address >> page_size_result) << std::endl;\n    log_file << "[MMU] Software TLB Hit Tag: " << tag << std::endl;\n    log_file << "[MMU] Software TLB Hit Latency: "\n                << final_software_tlb_latency << std::endl;\n#endif\n}\n'})}),"\n",(0,i.jsxs)(t.ol,{start:"4",children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Software TLB Miss"}),":"]}),"\n"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["If all software TLBs miss (",(0,i.jsx)(t.code,{children:"!software_tlb_hit"}),"):"]}),"\n",(0,i.jsxs)(t.li,{children:["The maximum latency among all software TLB lookups is calculated and used as the ",(0,i.jsx)(t.code,{children:"final_software_tlb_latency"}),"."]}),"\n",(0,i.jsx)(t.li,{children:"Debug logs indicate the software TLB miss and the calculated latency."}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-cpp",children:'\t\t\tif (!software_tlb_hit)\n\t\t\t{\n\t\t\t\t// If all software TLBs missed, we take the max of the latencies\n#ifdef DEBUG_MMU\n\t\t\t\tlog_file << "[MMU] Software TLB Miss" << std::endl;\n#endif\n\t\t\t\tSubsecondTime max_software_tlb_latency = SubsecondTime::Zero();\n\t\t\t\tfor (int page_size = 0; page_size < number_of_page_sizes; page_size++)\n\t\t\t\t{\n\t\t\t\t\tmax_software_tlb_latency = max(max_software_tlb_latency, software_tlb_latency[page_size]);\n\t\t\t\t}\n\t\t\t\tfinal_software_tlb_latency = max_software_tlb_latency;\n\n\t\t\t\tif (count)\n\t\t\t\t\ttranslation_stats.software_tlb_latency += final_software_tlb_latency;\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\t// If we had a software TLB hit, accumulate the latency\n\t\t\t\tif (count)\n\t\t\t\t\ttranslation_stats.software_tlb_latency += final_software_tlb_latency;\n\t\t\t}\n\n#ifdef DEBUG_MMU\n\t\t\tlog_file << "[MMU] Final Software TLB Latency: "\n\t\t\t         << final_software_tlb_latency << std::endl;\n#endif\n'})}),"\n",(0,i.jsxs)(t.ol,{start:"5",children:["\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Latency Accumulation"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["Whether a software TLB hit or miss occurs, the final latency is accumulated into the ",(0,i.jsx)(t.code,{children:"translation_stats.software_tlb_latency"})," if the ",(0,i.jsx)(t.code,{children:"count"})," flag is set."]}),"\n"]}),"\n"]}),"\n",(0,i.jsxs)(t.li,{children:["\n",(0,i.jsxs)(t.p,{children:[(0,i.jsx)(t.strong,{children:"Debugging Support"}),":"]}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:["The code includes extensive debugging support (enabled via ",(0,i.jsx)(t.code,{children:"DEBUG_MMU"}),") to log detailed information about the TLB lookup process, hits, misses, and latencies for both hardware and software TLBs. DO NOT ENABLE DEBUGGING WHEN RUNNING EXPERIMENTS."]}),"\n"]}),"\n"]}),"\n"]})]})}function f(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(c,{...e})}):c(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>o,x:()=>l});var s=n(6540);const i={},a=s.createContext(i);function o(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function l(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(i):e.components||i:o(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);