"use strict";(self.webpackChunkvirtuoso=self.webpackChunkvirtuoso||[]).push([[650],{7294:e=>{e.exports=JSON.parse('{"version":{"pluginId":"default","version":"current","label":"Next","banner":null,"badge":false,"noIndex":false,"className":"docs-version-current","isLast":true,"docsSidebars":{"tutorialSidebar":[{"type":"link","label":"Getting Started","href":"/Virtuoso/docs/intro","docId":"intro","unlisted":false},{"type":"link","label":"Release Notes","href":"/Virtuoso/docs/release_notes","docId":"release_notes","unlisted":false},{"type":"category","label":"MMU Designs","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Baseline MMU","href":"/Virtuoso/docs/MMU Designs/baseline_mmu","docId":"MMU Designs/baseline_mmu","unlisted":false},{"type":"link","label":"Part-of-Memory TLB (POM-TLB) MMU Design","href":"/Virtuoso/docs/MMU Designs/mmu_pomtlb","docId":"MMU Designs/mmu_pomtlb","unlisted":false},{"type":"link","label":"Range Mappings MMU Design","href":"/Virtuoso/docs/MMU Designs/mmu_rmm","docId":"MMU Designs/mmu_rmm","unlisted":false},{"type":"link","label":"Page Table Walker","href":"/Virtuoso/docs/MMU Designs/performing_ptw","docId":"MMU Designs/performing_ptw","unlisted":false}],"href":"/Virtuoso/docs/category/mmu-designs"},{"type":"category","label":"Physical Memory Allocators","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Reservation-based Transparent Huge Pages","href":"/Virtuoso/docs/Physical Memory Allocators/reserve_thp","docId":"Physical Memory Allocators/reserve_thp","unlisted":false}],"href":"/Virtuoso/docs/category/physical-memory-allocators"},{"type":"category","label":"TLB Subsystem","collapsible":true,"collapsed":true,"items":[{"type":"link","label":"Translation Lookaside Buffer (TLB) Overview","href":"/Virtuoso/docs/TLB Subsystem/tlb","docId":"TLB Subsystem/tlb","unlisted":false},{"type":"link","label":"TLB Subsystem Overview","href":"/Virtuoso/docs/TLB Subsystem/tlb_hierarchy","docId":"TLB Subsystem/tlb_hierarchy","unlisted":false}]}]},"docs":{"intro":{"id":"intro","title":"Getting Started","description":"Virtuoso is a new simulation framework designed to enable fast and accurate prototyping and evaluation of virtual memory (VM) schemes.  It employs a lightweight userspace kernel, MimicOS, which imitates the desired OS kernel code, allowing researchers to simulate only the relevant OS routines and easily develop new OS modules.  Virtuoso\'s imitation-based OS simulation methodology facilitates the evaluation of hardware/OS co-designs by accurately modeling the interplay between OS routines and hardware components.","sidebar":"tutorialSidebar"},"MMU Designs/baseline_mmu":{"id":"MMU Designs/baseline_mmu","title":"Baseline MMU","description":"This document provides an in-depth walkthrough of the Memory Management Unit (MMU) implementation.","sidebar":"tutorialSidebar"},"MMU Designs/mmu_pomtlb":{"id":"MMU Designs/mmu_pomtlb","title":"Part-of-Memory TLB (POM-TLB) MMU Design","description":"In this section, we will discuss the implementation of the Part-of-Memory TLB (POM-TLB) MMU design. The POM-TLB design is a software-managed TLB that uses a software-managed L3 TLB to reduce the overhead of address translation. The POM-TLB design is based on the work by Papadopoulou et al..","sidebar":"tutorialSidebar"},"MMU Designs/mmu_rmm":{"id":"MMU Designs/mmu_rmm","title":"Range Mappings MMU Design","description":"In this section, we will discuss the implementation of the Range Mappings MMU design. The Range Mappings MMU design is based on the work by","sidebar":"tutorialSidebar"},"MMU Designs/performing_ptw":{"id":"MMU Designs/performing_ptw","title":"Page Table Walker","description":"The page table walker (PTW) is a critical component of the memory management unit (MMU) that translates virtual addresses to physical addresses. The PTW is responsible for walking the page table hierarchy to find the physical address corresponding to a given virtual address. This process involves multiple memory accesses and can be time-consuming, especially in systems with large page tables.","sidebar":"tutorialSidebar"},"Physical Memory Allocators/reserve_thp":{"id":"Physical Memory Allocators/reserve_thp","title":"Reservation-based Transparent Huge Pages","description":"This document provides an overview and explanation of the ReservationTHPAllocator class, a specialized physical memory allocator that reserves and promotes Transparent Huge Pages (THPs). The code is designed to integrate with a buddy allocator (provided through the Buddy class) to manage physical memory. The ultimate goal is to optimize memory allocations by utilizing 2MB pages wherever possible while allowing fallback to 4KB pages when needed.","sidebar":"tutorialSidebar"},"release_notes":{"id":"release_notes","title":"Release Notes","description":"2025-07: Planned 3rd Major Update","sidebar":"tutorialSidebar"},"TLB Subsystem/tlb":{"id":"TLB Subsystem/tlb","title":"Translation Lookaside Buffer (TLB) Overview","description":"This document provides an overview of a Translation Lookaside Buffer (TLB) implementation within the ParametricDramDirectoryMSI namespace. The TLB code, as well as its interaction with caches, prefetchers, and related memory subsystems, is described here. The goal of this TLB is to cache virtual-to-physical page translations, accelerating address translation requests and reducing memory access latencies.","sidebar":"tutorialSidebar"},"TLB Subsystem/tlb_hierarchy":{"id":"TLB Subsystem/tlb_hierarchy","title":"TLB Subsystem Overview","description":"This document describes the TLBHierarchy class and its role in instantiating and configuring a hierarchy of Translation Lookaside Buffers (TLBs). We also discuss how this subsystem enables TLB prefetching and page-size prediction.","sidebar":"tutorialSidebar"}}}}')}}]);