"use strict";(self.webpackChunkvirtuoso=self.webpackChunkvirtuoso||[]).push([[930],{7226:(e,n,t)=>{t.r(n),t.d(n,{assets:()=>c,contentTitle:()=>a,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"TLB Subsystem/tlb_hierarchy","title":"TLB Subsystem Overview","description":"This document describes the TLBHierarchy class and its role in instantiating and configuring a hierarchy of Translation Lookaside Buffers (TLBs). We also discuss how this subsystem enables TLB prefetching and page-size prediction.","source":"@site/docs/TLB Subsystem/tlb_hierarchy.md","sourceDirName":"TLB Subsystem","slug":"/TLB Subsystem/tlb_hierarchy","permalink":"/Virtuoso/docs/TLB Subsystem/tlb_hierarchy","draft":false,"unlisted":false,"editUrl":"https://github.com/facebook/docusaurus/tree/main/packages/create-docusaurus/templates/shared/docs/TLB Subsystem/tlb_hierarchy.md","tags":[],"version":"current","frontMatter":{},"sidebar":"tutorialSidebar","previous":{"title":"Translation Lookaside Buffer (TLB) Overview","permalink":"/Virtuoso/docs/TLB Subsystem/tlb"}}');var s=t(4848),r=t(8453);const l={},a="TLB Subsystem Overview",c={},o=[{value:"Table of Contents",id:"table-of-contents",level:2},{value:"Introduction",id:"introduction",level:2},{value:"TLBHierarchy Class",id:"tlbhierarchy-class",level:2},{value:"Constructor",id:"constructor",level:3},{value:"Includes and Namespaces",id:"includes-and-namespaces",level:4},{value:"Resizing Internal Data Structures",id:"resizing-internal-data-structures",level:3},{value:"Creating TLB Objects for Each Level",id:"creating-tlb-objects-for-each-level",level:3},{value:"Loop Over Each TLB at a Given Level",id:"loop-over-each-tlb-at-a-given-level",level:3},{value:"Latency, Page Size List, and Logging",id:"latency-page-size-list-and-logging",level:3},{value:"Creating the TLB and Storing in Vectors",id:"creating-the-tlb-and-storing-in-vectors",level:3},{value:"Handling Prefetch-Enabled Case",id:"handling-prefetch-enabled-case",level:3},{value:"Page-Size Predictor Creation",id:"page-size-predictor-creation",level:3}];function d(e){const n={a:"a",code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,r.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"tlb-subsystem-overview",children:"TLB Subsystem Overview"})}),"\n",(0,s.jsxs)(n.p,{children:["This document describes the ",(0,s.jsx)(n.strong,{children:"TLBHierarchy"})," class and its role in instantiating and configuring a hierarchy of Translation Lookaside Buffers (TLBs). We also discuss how this subsystem enables TLB prefetching and page-size prediction."]}),"\n",(0,s.jsxs)(n.p,{children:["Below, you will find the implementation of the ",(0,s.jsx)(n.code,{children:"TLBHierarchy"})," constructor split into logical sections with explanatory comments in between. This should help you understand how the TLB hierarchy is created, configured, and managed within the memory subsystem."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"table-of-contents",children:"Table of Contents"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#introduction",children:"Introduction"})}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.a,{href:"#tlbhierarchy-class",children:"TLBHierarchy Class"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#constructor",children:"Constructor"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#predictpagesize",children:"predictPagesize()"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#predictionresult",children:"predictionResult()"})}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#destructor",children:"Destructor"})}),"\n"]}),"\n"]}),"\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.a,{href:"#conclusion",children:"Conclusion"})}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"introduction",children:"Introduction"}),"\n",(0,s.jsxs)(n.p,{children:["The code below shows how a TLB hierarchy is built from a configuration (using ",(0,s.jsx)(n.code,{children:"Sim()->getCfg()"}),' to read parameters). Each "level" in the TLB hierarchy can have multiple TLB structures (data, instruction, or unified), and there may be an optional prefetcher queue (PQ). The code also integrates with a ',(0,s.jsx)(n.strong,{children:"page size predictor"})," to dynamically guess the most likely page size for each instruction pointer (EIP)."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"tlbhierarchy-class",children:"TLBHierarchy Class"}),"\n",(0,s.jsx)(n.h3,{id:"constructor",children:"Constructor"}),"\n",(0,s.jsx)(n.h4,{id:"includes-and-namespaces",children:"Includes and Namespaces"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'#include "tlb_subsystem.h"\n#include "tlb.h"\n#include <boost/algorithm/string.hpp>\n#include "config.hpp"\n#include "stride_prefetcher.h"\n#include "tlb_prefetcher_factory.h"\n#include "pagesize_predictor_factory.h"\n#include "dvfs_manager.h"\n\nusing namespace boost::algorithm;\nExplanation\n\nBrings in required headers for TLB structures, configuration parsing, prefetcher factories, DVFS management, etc.\nWe use boost::algorithm primarily for string manipulation like to_lower_copy, trim, etc.\nConstructor Signature and Initialization\ncpp\nCopy\nEdit\nnamespace ParametricDramDirectoryMSI\n{\n\n\tTLBHierarchy::TLBHierarchy(String mmu_name, Core *core, MemoryManager *memory_manager, ShmemPerfModel *shmem_perf_model)\n\t{\n\t\tstd::cout << "[MMU] Instantiating TLB Hierarchy" << std::endl;\n```markdown\nExplanation\n\nThe constructor logs a message indicating that the TLB hierarchy is being instantiated.\nReceives references to the core, memory manager, and shared memory performance model, which are essential for the TLB\u2019s operation within the simulator.\n\n### Reading Basic Configuration\n\n```cpp\n        numLevels = Sim()->getCfg()->getInt("perf_model/"+mmu_name+"/tlb_subsystem/number_of_levels");\n        prefetch_enabled = Sim()->getCfg()->getBool("perf_model/"+mmu_name+"/tlb_subsystem/prefetch_enabled");\n        int add_extra_level = 0;\n        if (prefetch_enabled)\n            add_extra_level = 1;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"numLevels"}),": The number of TLB levels from the config (for example, L1, L2, L3 TLB)."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"prefetch_enabled"}),': Whether an extra TLB "queue" (PQ) will be added for prefetching.']}),"\n",(0,s.jsxs)(n.li,{children:["If ",(0,s.jsx)(n.code,{children:"prefetch_enabled"})," is true, we bump the total number of TLB levels by 1."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"resizing-internal-data-structures",children:"Resizing Internal Data Structures"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:"        tlbLevels.resize(numLevels + add_extra_level);\n        data_path.resize(numLevels + add_extra_level);\n        instruction_path.resize(numLevels + add_extra_level);\n        tlb_latencies.resize(numLevels + add_extra_level);\n"})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsx)(n.p,{children:"We maintain several parallel vectors to handle:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tlbLevels"}),": The complete set of TLB objects per level."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"data_path"}),": The TLBs servicing data accesses."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"instruction_path"}),": The TLBs servicing instruction fetches."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"tlb_latencies"}),": Latency information per TLB."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"creating-tlb-objects-for-each-level",children:"Creating TLB Objects for Each Level"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'        for (int level = 1; level <= numLevels; ++level)\n        {\n            std::string level_str = std::to_string(level);\n            String levelString = String(level_str.begin(), level_str.end());\n\n            int numTLBs = (Sim()->getCfg()->getInt("perf_model/"+mmu_name+"/tlb_level_" + levelString + "/number_of_tlbs"));\n\n            tlbLevels[level - 1].reserve(numTLBs);\n            data_path[level - 1].reserve(numTLBs);\n            instruction_path[level - 1].reserve(numTLBs);\n            tlb_latencies[level - 1].reserve(numTLBs);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"For each TLB level (e.g., L1, L2, ... Ln), read how many TLBs exist at that level."}),"\n",(0,s.jsx)(n.li,{children:"Reserve space in the relevant vectors to store these TLBs."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"loop-over-each-tlb-at-a-given-level",children:"Loop Over Each TLB at a Given Level"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'            for (int tlbIndex = 1; tlbIndex <= numTLBs; ++tlbIndex)\n            {\n                std::string tlbIndex_str = std::to_string(tlbIndex);\n\n                String tlbIndexString = String(tlbIndex_str.begin(), tlbIndex_str.end());\n                String tlbconfigstring = "perf_model/"+mmu_name+"/tlb_level_" + levelString + "/tlb" + tlbIndexString;\n                String type = Sim()->getCfg()->getString("perf_model/"+mmu_name+"/tlb_level_" + levelString + "/tlb" + tlbIndexString + "/type");\n                int size = Sim()->getCfg()->getInt("perf_model/"+mmu_name+"/tlb_level_" + levelString + "/tlb" + tlbIndexString + "/size");\n                int assoc = Sim()->getCfg()->getInt("perf_model/"+mmu_name+"/tlb_level_" + levelString + "/tlb" + tlbIndexString + "/assoc");\n                page_sizes = Sim()->getCfg()->getInt("perf_model/"+mmu_name+"/tlb_level_" + levelString + "/tlb" + tlbIndexString + "/page_size");\n                int *page_size_list = (int *)malloc(sizeof(int) * (page_sizes));\n                bool allocate_on_miss = Sim()->getCfg()->getBool("perf_model/"+mmu_name+"/tlb_level_" + levelString + "/tlb" + tlbIndexString + "/allocate_on_miss");\n'})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsx)(n.p,{children:"For each TLB at a given level, read:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"type"}),": Data, Instruction, or a unified TLB."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"size"}),": Number of entries."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"assoc"}),": Associativity."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"page_sizes"}),": How many page-size variants are supported by this TLB."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"page_size_list"}),": A list of actual page sizes."]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"allocate_on_miss"}),": Flag controlling whether new translations are inserted on a miss."]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"latency-page-size-list-and-logging",children:"Latency, Page Size List, and Logging"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'                ComponentLatency latency = ComponentLatency(core ? core->getDvfsDomain() : Sim()->getDvfsManager()->getGlobalDomain(DvfsManager::DvfsGlobalDomain::DOMAIN_GLOBAL_DEFAULT),\n                                                            Sim()->getCfg()->getInt("perf_model/"+mmu_name+"/tlb_level_" + levelString + "/tlb" + tlbIndexString + "/access_latency"));\n\n                for (int i = 0; i < page_sizes; i++)\n                    page_size_list[i] = Sim()->getCfg()->getIntArray("perf_model/"+mmu_name+"/tlb_level_" + levelString + "/tlb" + tlbIndexString + "/page_size_list", i);\n\n                std::string tlbName = "TLB_L" + std::to_string(level) + "_" + std::to_string(tlbIndex);\n                String tlbname = String(tlbName.begin(), tlbName.end());\n                String full_name = mmu_name+"_"+tlbname;\n\n                std::cout << "TLB: " << tlbName << ", type: " << type << ", size: " << size << ", assoc: " << assoc << ", page sizes: ";\n\n                for (int i = 0; i < page_sizes; i++)\n                    std::cout << page_size_list[i] << " ";\n\n                std::cout << std::endl;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Compute the TLB\u2019s access latency, either based on the core\u2019s DVFS domain or a global default."}),"\n",(0,s.jsx)(n.li,{children:"Retrieve each supported page size from the config file\u2019s array."}),"\n",(0,s.jsx)(n.li,{children:'Construct a name like "TLB_L1_1", "TLB_L1_2", etc., for logging.'}),"\n",(0,s.jsx)(n.li,{children:"Print a summary of the TLB\u2019s configuration to stdout."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"creating-the-tlb-and-storing-in-vectors",children:"Creating the TLB and Storing in Vectors"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'                TLB *tlb = new TLB(full_name, tlbconfigstring, core ? core->getId() : 0, latency, size, assoc, page_size_list, page_sizes, type, allocate_on_miss);\n\n                tlbLevels[level - 1].push_back(tlb);\n                if (type == "Data")\n                    data_path[level - 1].push_back(tlb);\n                else if (type == "Instruction")\n                    instruction_path[level - 1].push_back(tlb);\n                else\n                {\n                    data_path[level - 1].push_back(tlb);\n                    instruction_path[level - 1].push_back(tlb);\n                }\n            }\n        }\n'})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Allocates a new TLB object."}),"\n",(0,s.jsxs)(n.li,{children:["Adds that TLB to ",(0,s.jsx)(n.code,{children:"tlbLevels"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"Also adds it to either the data path, the instruction path, or both, based on type."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"handling-prefetch-enabled-case",children:"Handling Prefetch-Enabled Case"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'        if (prefetch_enabled)\n        {\n            std::cout << "Prefetch Enabled" << std::endl;\n            int numpqs = (Sim()->getCfg()->getInt("perf_model/tlb_prefetch/number_of_pqs"));\n            tlbLevels[numLevels].reserve(numpqs);\n            data_path[numLevels].reserve(numpqs);\n            instruction_path[numLevels].reserve(numpqs);\n            tlb_latencies[numLevels].reserve(numpqs);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsxs)(n.p,{children:['If TLB prefetching is enabled, an extra "level" (the prefetch queue, or PQ) is created.\nThe code below will read how many prefetch queues exist (',(0,s.jsx)(n.code,{children:"numpqs"}),") and configure them."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'            for (int pqIndex = 1; pqIndex <= numpqs; pqIndex++)\n            {\n                std::string pqIndex_str = std::to_string(pqIndex);\n                String pqIndexString = String(pqIndex_str.begin(), pqIndex_str.end());\n                String pqconfigstring = "perf_model/"+mmu_name+"/tlb_prefetch/pq" + pqIndexString;\n                String type = Sim()->getCfg()->getString("perf_model/tlb_prefetch/pq" + pqIndexString + "/type");\n\n                int* page_size_list = (int *)malloc(sizeof(int) * 2);\n                page_size_list[0] = 12;\n                page_size_list[1] = 21;\n                \n                int size = Sim()->getCfg()->getInt("perf_model/"+mmu_name+"/tlb_prefetch/pq" + pqIndexString + "/size");\n                std::string pqName = "PQ_" + std::to_string(pqIndex);\n                String pqname = String(pqName.begin(), pqName.end());\n                int number_of_prefetchers = Sim()->getCfg()->getInt("perf_model/"+mmu_name+"/tlb_prefetch/pq" + pqIndexString + "/number_of_prefetchers");\n                TLBPrefetcherBase **prefetchers = (TLBPrefetcherBase **)malloc(sizeof(TLBPrefetcherBase *) * number_of_prefetchers);\n                std::cout << "TLB Prefetchers: " << number_of_prefetchers << std::endl;\n'})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"pqIndex"}),": Index into the prefetch queues."]}),"\n",(0,s.jsxs)(n.li,{children:["Hard-coded ",(0,s.jsx)(n.code,{children:"page_size_list"})," with two entries (just for demonstration or specialized usage)."]}),"\n",(0,s.jsx)(n.li,{children:"Each PQ can also have multiple prefetcher objects. We allocate them dynamically."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'                for (int i = 0; i < number_of_prefetchers; i++)\n                {\n                    String name = Sim()->getCfg()->getStringArray("perf_model/"+mmu_name+"/tlb_prefetch/pq" + pqIndexString + "/prefetcher_list", i);\n                    prefetchers[i] = TLBprefetcherFactory::createTLBPrefetcher(name, pqIndexString, core, memory_manager, shmem_perf_model);\n                }\n\n                ComponentLatency latency = ComponentLatency(core->getDvfsDomain(), Sim()->getCfg()->getInt("perf_model/"+mmu_name+"/tlb_prefetch/pq" + pqIndexString + "/access_latency"));\n\n                TLB *pq = new TLB(pqname, pqconfigstring, core->getId(), latency, size, 1, page_size_list, 2, type, false, true, prefetchers, number_of_prefetchers);\n'})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"TLBprefetcherFactory::createTLBPrefetcher(...)"})," dynamically instantiates each prefetcher by name."]}),"\n",(0,s.jsxs)(n.li,{children:["Create a new TLB (treated as a PQ) with ",(0,s.jsx)(n.code,{children:"prefetch = true"}),"."]}),"\n",(0,s.jsx)(n.li,{children:"This queue can be inserted into the TLB hierarchy just like another level."}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'                tlbLevels[numLevels].push_back(pq);\n                if (type == "Data")\n                    data_path[numLevels].push_back(pq);\n                else if (type == "Instruction")\n                    instruction_path[numLevels].push_back(pq);\n                else\n                {\n                    data_path[numLevels].push_back(pq);\n                    instruction_path[numLevels].push_back(pq);\n                }\n            }\n            numLevels++;\n        }\n'})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:["We place the PQ into ",(0,s.jsx)(n.code,{children:"tlbLevels"}),' at the new prefetch "level" index.']}),"\n",(0,s.jsx)(n.li,{children:"This extends data/instruction path coverage as well."}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"page-size-predictor-creation",children:"Page-Size Predictor Creation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-cpp",children:'        String pagesize_type = Sim()->getCfg()->getString("perf_model/"+mmu_name+"/tlb_subsystem/pagesize_predictor_name");\n        page_size_predictor = NULL;\n        page_size_predictor = PagesizePredictorFactory::createPagesizePredictor(pagesize_type);\n        std::cout << "Tlb levels: " << tlbLevels.size() << std::endl;\n    }\n'})}),"\n",(0,s.jsx)(n.p,{children:"Explanation"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"The constructor reads the type of page-size predictor to instantiate."}),"\n",(0,s.jsxs)(n.li,{children:["Uses a ",(0,s.jsx)(n.code,{children:"PagesizePredictorFactory"})," to create the appropriate predictor based on the name from config."]}),"\n"]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{})})]})}function h(e={}){const{wrapper:n}={...(0,r.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(d,{...e})}):d(e)}},8453:(e,n,t)=>{t.d(n,{R:()=>l,x:()=>a});var i=t(6540);const s={},r=i.createContext(s);function l(e){const n=i.useContext(r);return i.useMemo((function(){return"function"==typeof e?e(n):{...n,...e}}),[n,e])}function a(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(r.Provider,{value:n},e.children)}}}]);